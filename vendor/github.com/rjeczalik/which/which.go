package which

import (
	"debug/gosym"
	"errors"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// TODO(rjeczalik): support all platform types

func init() {
	// Add $GOROOT and $GOROOT_FINAL to the filtered paths.
	goroot := runtime.GOROOT()
	filtered[goroot] = struct{}{}
	if err := os.Setenv("GOROOT", ""); err == nil {
		filtered[runtime.GOROOT()] = struct{}{} // $GOROOT_FINAL
		os.Setenv("GOROOT", goroot)
	}
	// Make the order of file factory methods platform-specific.
	switch runtime.GOOS {
	case "darwin":
		alltbl = append(alltbl, newmacho, newelf, newpe)
	case "windows":
		alltbl = append(alltbl, newpe, newmacho, newelf)
	default:
		alltbl = append(alltbl, newelf, newmacho, newpe)
	}
}

type tabler interface {
	Close() error
	Pcln() ([]byte, error)
	Sym() ([]byte, error)
	Text() (uint64, error)
	Type() *PlatformType
}

// All supported symbol table builders.
var alltbl []func(string) (tabler, error)

// A path is discarded if it contains any of the filtered strings.
// TODO(rjeczalik): add $HOME/.gvm/gos?
var filtered = map[string]struct{}{
	filepath.FromSlash("/tmp/makerelease"):  {},
	filepath.FromSlash("<autogenerated>"):   {},
	filepath.FromSlash("c:/go/src"):         {},
	filepath.FromSlash("/usr/local/go/src"): {},
}

var (
	// ErrNotGoExec is an error.
	ErrNotGoExec = errors.New("which: not a Go executable")
	// ErrGuessFail is an error.
	ErrGuessFail = errors.New("which: unable to guess an import path of the main package")
)

// PlatformType represents the target platform of the executable.
type PlatformType struct {
	GOOS   string // target operating system
	GOARCH string // target architecture
}

// String gives Go platform string.
func (typ PlatformType) String() string {
	return typ.GOOS + "_" + typ.GOARCH
}

var (
	// PlatformDarwin386 represents the darwin_386 target arch.
	PlatformDarwin386 = &PlatformType{"darwin", "386"}
	// PlatformDarwinAMD64 represents the darwin_amd64 target arch.
	PlatformDarwinAMD64 = &PlatformType{"darwin", "amd64"}
	// PlatformFreeBSD386 represents the freebsd_386 target arch.
	PlatformFreeBSD386 = &PlatformType{"freebsd", "386"}
	// PlatformFreeBSDAMD64 represents the freebsd_amd64 target arch.
	PlatformFreeBSDAMD64 = &PlatformType{"freebsd", "amd64"}
	// PlatformLinux386 represents the linux_386 target arch.
	PlatformLinux386 = &PlatformType{"linux", "386"}
	// PlatformLinuxAMD64 represents the linux_amd64 target arch.
	PlatformLinuxAMD64 = &PlatformType{"linux", "amd64"}
	// PlatformWindows386 represents the windows_386 target arch.
	PlatformWindows386 = &PlatformType{"windows", "386"}
	// PlatformWindowsAMD64 represents the windows_amd64 target arch.
	PlatformWindowsAMD64 = &PlatformType{"windows", "amd64"}
)

// Exec represents a single Go executable file.
type Exec struct {
	Path  string        // Path to the executable.
	Type  *PlatformType // Fileutable file format.
	table *gosym.Table
}

// NewExec tries to detect executable type for the given path and returns
// a new executable. It fails if file does not exist, is not a Go executable or
// it's unable to parse the file format.
func NewExec(path string) (*Exec, error) {
	typ, symtab, pclntab, text, err := newtbl(path)
	if err != nil {
		return nil, err
	}
	lntab := gosym.NewLineTable(pclntab, text)
	if lntab == nil {
		return nil, ErrNotGoExec
	}
	tab, err := gosym.NewTable(symtab, lntab)
	if err != nil {
		return nil, ErrNotGoExec
	}
	return &Exec{Path: path, Type: typ, table: tab}, nil
}

// Import gives the import path of main package of given executable. It returns
// non-nil error when it fails to guess the exact path.
func (ex *Exec) Import() (string, error) {
	var dirs = make(map[string]struct{})
	for file, obj := range ex.table.Files {
		for i := range obj.Funcs {
			// main.main symbol is referenced by every file of each package
			// imported by the main package of the executable.
			if obj.Funcs[i].Sym.Name == "main.main" && !isfiltered(file) {
				dirs[filepath.Dir(file)] = struct{}{}
			}
		}
	}
	name := filepath.Base(ex.Path)
	if ex.Type == PlatformWindows386 || ex.Type == PlatformWindowsAMD64 {
		name = strings.TrimRight(name, ".exe")
	}
	if pkg, unique := guesspkg(name, dirs); unique && pkg != "" {
		return pkg, nil
	}
	return "", ErrGuessFail
}

// Import reads the import path of main package of the Go executable given by
// the path.
func Import(path string) (string, error) {
	ex, err := NewExec(path)
	if err != nil {
		return "", err
	}
	return ex.Import()
}

func newtbl(path string) (typ *PlatformType, symtab, pclntab []byte, text uint64, err error) {
	var tbl tabler
	fail := func() {
		err = errors.New("which: unable to read Go symbol table: " + err.Error())
		tbl.Close()
	}
	for _, newt := range alltbl {
		if tbl, err = newt(path); err != nil {
			err = ErrNotGoExec
			continue
		}
		if symtab, err = tbl.Sym(); err != nil {
			fail()
			continue
		}
		if pclntab, err = tbl.Pcln(); err != nil {
			fail()
			continue
		}
		if text, err = tbl.Text(); err != nil {
			fail()
			continue
		}
		typ = tbl.Type()
		tbl.Close()
		break
	}
	return
}

func isfiltered(file string) bool {
	for f := range filtered {
		if strings.Contains(file, f) {
			return true
		}
	}
	return false
}

var src = filepath.FromSlash("/src/")

func guesspkg(name string, dirs map[string]struct{}) (pkg string, unique bool) {
	defer func() {
		pkg = filepath.ToSlash(pkg)
	}()
	for _, s := range []string{"cmd" + string(os.PathSeparator) + name, name} {
		for dir := range dirs {
			if strings.Contains(dir, s) {
				if i := strings.LastIndex(dir, src); i != -1 {
					pkg = dir[i+len(src):]
					if unique {
						unique = false
						return
					}
					unique = true
				}
			}
		}
		if unique {
			return
		}
	}
	return
}
